# 알고리즘에 대한 성능평가 기준 5가지

​

### ●  프로세서 이용률(CPU Utilization)

**`시간당 CPU를 사용한 시간의 비율`**

프로세서를 실행상태로 항상 유지하여 유휴상태가 되지 않도록 한다. 가능하면 입출력(I/O) 중심의 작업보다 프로세서 중심의 작업을 실행해야한다.

​

### ●  처리율(Throughput)

**`시간당 처리한 작업의 비율`**

단위 시간당 완료되는 작업 수가 많도록 짧은 작업을 우선 처리하거나 인터럽트 없이 작업을 실행한다.

​

### ●  반환시간 또는 소요시간(Turnaround Time)

**`CPU burst time(쓰고 나갈때까지의 시간, 누적되지 않음)`**

작업이 시스템에 맡겨져서 메인 메모리에 들어가기까지의 시간, 준비 큐에 있는 시간, 실행 시간, 입출력 시간 등 작업 제출 후 완료되는 순간까지의 소요시간이 최소화되도록 일괄 처리 작업을 우선 처리한다.
(끝난시간 - 도착시간)

​

### ●  대기시간(Waiting Time)

**`대기열에 들어와 CPU를 할당받기까지 기다린 시간`**

작업의 실행시간이나 입출력시간에는 실제적인 영향을 미치지 못하므로 준비 큐애서 기다리는 시간이 최소화되도록 사용자 수를 제한한다.  

즉, Ready Queue에서 기다리는 시간을 최소화 시킨다.    (시작시간 - 도착시간)

​<br>

### ●  반응시간 또는 응답시간(Response Time)

**`대기열에서 처음으로 CPU를 얻을때까지 걸린시간`**

반응시간은 의뢰한 시간에서부터 반응이 시작되는 시간까지의 간격으로 대화형 시스템에서 중요한 사항이다. 따라서 대화식 작업을 우선 처리하고 일괄 처리 작업은 대화식 작업의 요구가 없을때까지 처리한다.

***반환시간 :: 끝난시간 - 도착시간***

<br>

![response](https://postfiles.pstatic.net/MjAyMjA3MDlfMzQg/MDAxNjU3MzU1ODA3ODE5.AjRA8r-whn78wEOaK2__sgM6i7HvndwPWuZgOa7ob0kg.D6qG3gHYDwcwmimvxflR61aj5cfa5vEHhZ24gUKoX8Ag.PNG.wndgndi/image.png?type=w773)

<br>
<br>

### [ 주체별 CPU 성능 척도 ]



시스템 입장에서의 CPU 스케줄링 성능에서 중요한 것  
▶ CPU Utilization + Throughput

​

사용자 입장에서의 CPU 스케줄링 성능에서 중요한 것  
▶ Turnaround Time + Waiting Time + Response Time

<br>

---

## CPU Scheduling Algorithm



해당 알고리즘은 Ready Queue에 있는 프로세스를 대상으로 다음에 어떤 작업을 CPU에 할당할 것인지를 정하는 알고리즘이다.

들어가기 전에, 해당용어를 정리하겠다.

​

-  선점(preemptive) 

    : 우선순위가 높은 작업이 오거나, 해당 작업이 더 우선되어야 한다고 판단되면  해당 작업에게서 CPU를 빼앗을 수 있다.

​

-  비선점(non-preemptive) 

   : 일단 CPU를 할당받으면 해당 프로세스가 끝날때까지 CPU를 빼앗기지 않는다.

   <br>

   ---

###  비선점 방법

​

## FCFS(First Come First Served)

​

### 특징

선입선처리 스케줄링은 비선점 방법이며 프로세서 스케줄링 알고리즘 중 가장 간단하지만 비효율적이다.

프로세서를 요청하는 순서대로 프로세서를 할당해준다. 이때 구현은 Queue로 하며 FIFO 형태를 이룬다.

​

### 장점

-  스케줄링의 구현이 쉽다.

-  Ready Queue에 있는 모든 프로세스가 실행될 수 있으므로 Starvation이 없다.

-  프로세서가 지속적으로 프로세스를 처리하므로 처리율이 높다.

​

### 단점

-  응답시간이 길어질 수 있음

-  Convey Effect(호위 효과)
*(Short process behind long process: 하나의 프로세서 중심 프로세스가 프로세스를 떠나기를 기다리는 현상 )*

<Br>

![FCFS](https://postfiles.pstatic.net/MjAyMjA3MTBfMjMg/MDAxNjU3MzkxMjY4OTU2.uXiAtXnTsWwu1qvLsuBur9kZrvk0dhUNHnAg8lXhTUkg.Vwmw8tk09JeFuR1MHOwZ1k1NPB121jXLyAFYBdDpRbIg.PNG.wndgndi/image.png?type=w773)

<Br>

|프로세스|도착시간|실행시간|
|:-----:|:------:|:-----:|
|P1     |0       |10     |
|P2|1|20|
|P3|2|25|
|P4|3|14|
|P5|4|18|

<br>

이 상황에서는 아래 그림으로 다음과 같이 나타낼 수 있다.

<Br>

![FCFS2](https://postfiles.pstatic.net/MjAyMjA3MTBfMjQx/MDAxNjU3MzkxNDMxNTY2.gt0qb5LbbYbHhF_Kb71rhAy5Z2rI_F3MzgZFwePq5NQg.HMSvK4vi3rRMbMYEV5J9xtC6TCaBclxM6HnripKdCAYg.PNG.wndgndi/image.png?type=w773)

<br>

### 대기 시간

P1 :: 0

P2 :: 10 - 1 = 9

P3 :: 30 - 2 = 28

P4 :: 55 - 3 = 52

P5 :: 69 - 4 = 65


**`평균 대기시간 = (0 + 9 + 28 + 52 + 65) / 5 = 30.8`**

​<Br>

### 반환 시간

P1 :: 10 - 0 = 10

P2 :: 30 - 1= 29

P3 :: 55 - 2 = 53

P4 :: 69 - 3 = 66

P5 :: 87 - 4 = 83​

**`평균 반환시간 :: (10 + 29 + 53 + 66 + 83) / 5 = 48.2`**

<Br>

---

## SJF(Shortest Job First)

​

### 특징

-  CPU burst time이 짧은 작업을 우선으로 할당하는 방법

-  각 프로세스와 다음번 CPU burst time을 가지고 스케줄링에 할당  
( 일종의 우선순위 기법 priority = predicted next CPU burst time )

-  비선점형(SJF)과 선점형(SRTF) 방식이 있음

-  최소 평균 대기 시간을 보장한다.

-  FCFS의 방법과는 같지만 실행 시간이 작은 순서대로 우선순위 큐를 이용한다고 생각하면 된다.

​

### 장점

-  항상 실행 시간이 짧은 작업을 가장 먼저 실행하므로 평균 대기시간이 가장 짧다.

​

### 단점

-  Starvation(기아 현상) 발생 가능성이 있음

-  기본적으로 짧은 작업이 항상 먼저 시작되기에 불공평하다.

-  실행시간을 예측하기 어렵다.

<Br>

![SJF](https://postfiles.pstatic.net/MjAyMjA3MTFfNTkg/MDAxNjU3NTE4NzQ5NDYw.7Ua95cZMVNF4hdF_tPN4ampIE3To_hY6v_AjYpeAougg.46KRcdZTZeahXk1L8_eUTZcSi8fCNzHohSDWeoakwgEg.PNG.wndgndi/image.png?type=w773)

<Br>

|프로세스|도착시간|실행시간|
|:-----:|:------:|:-----:|
|P1     |0       |10     |
|P2|1|20|
|P3|2|25|
|P4|3|14|
|P5|4|18|

<br>

![SJF2](https://postfiles.pstatic.net/MjAyMjA3MTFfODAg/MDAxNjU3NTE4OTA1NDI4.7cgJCs7mJLEtBgCJOIpl0c2_D2J9KOrZgAGwdVTGxHUg.3IubJ9c3gW7VgLOQpUaDs8ShFvAXrc54_bwE2uoIcbwg.PNG.wndgndi/image.png?type=w773)

<br>

### 대기 시간

P1 :: 0

P2 :: 42 - 1 = 41

P3 :: 62 - 2 = 60

P4 :: 10 - 3 = 7

P5 :: 24 - 4 = 20

​
**`평균 대기시간 = (0 + 41 + 60 + 7 + 20) / 5 = 25`**

​<Br>

### 반환 시간

P1 :: 10 - 0 = 10

P2 :: 62 - 1= 61

P3 :: 87 - 2 = 85

P4 :: 24 - 3 = 21

P5 :: 42 - 4 = 38

​
**`평균 반환시간 :: (10 + 61 + 85 + 21 + 38) / 5 = 43`**

