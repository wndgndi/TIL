# 시스템 콜 이란

​

시스템 호출(system call)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.

**즉, System Call 은 사용자 프로세스가 소프트웨어 인터럽트를 통해 커널의 기능을 이용하기 위한 서비스를 요청하는 하나의 방법이다.**

---

### [ 처리방식 ]

1. 사용자 프로세스가 시스템 콜을 요청하면 제어가 커널로 넘어옴. *(사용자 모드 -> 커널 모드)*

2. 커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유번호를 할당하고 그 번호에 해당하는 제어루틴을 커널 내부에 정의.

3. 커널은 요청받은 시스템 콜에 대응하는 기능번호를 확인.

4. 커널은 그 번호에 맞는 서비스 루틴을 호출.

5. 서비스 루틴을 모두 처리하고 나면 커널 모드에서 사용자 모드로 다시 전환.

---

### [ 시스템 콜은 왜 필요할까? ]

​

우리가 일반적으로 사용하는 프로그램은 '응용프로그램'이다. 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기 때문에, `커널(kernel)`의 도움을 반드시 받아야 한다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드에서는 수행할 수 없다. 
반드시 커널에 관련된 것은 커널모드로 전환한 후에야, 해당 작업을 수행할 권한이 생긴다. 
커널 모드를 통한 이러한 작업은 반드시 시스템 콜을 통해 수행하도록 설계되어 있다. 

아래 그림(1.13)을 살펴보면 이해가 빠를 것이다.

<br>

![1.13](https://blog.kakaocdn.net/dn/JXwNG/btqw787Kgfe/vmrkitiEEjDI8G9w2mFzUk/img.png)

<Br>

그렇다면 권한은 왜 필요한 것일까? 의문이 생길 수 있다. 
그 이유는 해커가 피해를 입히기 위해 악의적으로 시스템 콜을 사용하는 경우나 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수도 있기 때문이다. 

따라서 이러한 명령어들은 특별하게 커널 모드에서만 실행할 수 있도록 설계되었고, 만약 유저 모드에서 시스템 콜을 호출할 경우에는 운영체제에서 불법적인 접근이라 여기고 trap을 발생시킨다.

---

### [ System Call 기능 ]

-  사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다.

-  시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다.

-  커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다.

---

### [ 시스템 콜 예시 ]

<br>

```
cp in.txt out.txt
```

리눅스 터미널에 위와 같은 명령어를 입력한다면 이때 순차적으로 호출되는 시스템 콜은 어떤 것이 있을까 생각해보자. 참고로 위의 문장은 in.txt에 있는 파일내용과 같은 내용을 복사하여 out.txt 파일을 만드는 것이다.

일반적으로 윈도우 운영체제라면 라면 마우스가, 리눅스라면 키보드가 사용자로부터 입력을 받는데 이때 I/O 시스템 콜을 사용한다. 위와 같은 문장을 입력을 받아서 'cp' 프로그램을 실행시키면 먼저 'in.txt' 파일이 현재 디렉터리에서 접근할 수 있는 파일인지를 검사하기 위해 시스템 콜을 호출한다.​

만약 파일이 존재하지 않는 다면 애러를 발생시켜야 하고, 프로그램을 종료하는데 이때 시스템 콜이 사용된다. 만약 파일이 존재한다면, 복사한 파일을 저장하기 위해 'output.txt' 파일명이 있는지 검사한다. 

그리고 이 때도 마찬가지로 이 파일 명이 존재하는지 존재하지 않는지 검사하기 위해 시스템 콜을 통해 확인한다. 

그리고 만약 파일 명이 이미 존재한다면, 덮어 씌워야 할지 아니면, 이어서 붙여야 하는지 User에게 물어볼 수 있다. 만약 저장하고자 하는 파일 이름이 겹치지 않다면, 파일을 저장해야 하는데 이 때도 시스템 콜을 이용한다. 

​

그림 2.5는 이 과정에서 필요한 시스템 콜의 호출 과정을 나타낸 것이다.

![system call2](https://blog.kakaocdn.net/dn/bAPjla/btqw7Qe9Ppa/FhpxhmnirEN1k63R6Qr3nk/img.png)

<br>

텍스트를 복사하는 간단한 프로그램임에도 불구하고, 상당히 많은 시스템 콜이 발생함을 알 수 있다. 
그리고 아래는 시스템 콜의 종류이다. UNIX 운영체제의 실재 응용프로그램에서 수행하는 시스템 콜 함수의 이름이다.

---

### [ 시스템 콜의 종류 ]

<br>
​
● 프로세스 컨트롤

-  프로세스 생성 및 종료

-  메모리에 로드, 실행

-  프로세스 속성 값 확인, 지정

-  wait 이벤트, signal 이벤트

-  메모리 할당

​

● 파일 메니지먼트​

-  파일 생성, 파일 삭제

-  열기, 닫기

-  읽기, 쓰기, Reposition

 - 파일 속성 값 확인, 지정

​

● 디바이스 매니지먼트

-  디바이스 요청 및 해제

-  읽기, 쓰기, Reposition

-  디바이스 속성 확인, 지정

-  비 물리적인 디바이스 해제 및 장착

​

● 정보 관리

-  시간 확인, 시간 지정

-  시스템 데이터 확인, 지정

-  프로세스, 파일, 디바이스 속성 가져오기

-  프로세스, 파일, 디바이스 속성 설정하기

​

● 커뮤니케이션​

-  커뮤니케이션 연결 생성 및 삭제

-  메시지 송신, 수신

-  상태 정보 전달

-  remote 디바이스 해제 및 장착

​

● 보안

-  Permission 획득

-  Permission 설정


---

### [ System Call 매개변수 전송 ]



필요한 기능이나 시스템 환경에 따라 System Call 이 발생할 때 좀 더 많은 정보가 필요할 수 있다. 

그러한 정보가 담긴 매개변수를 운영체제에 전달하기 위해서는 대략 3가지 정도의 방법이 있다.

​

#### 1)  레지스터를 통한 전송 

 

   -   매개변수를 CPU 레지스터 내에 전달한다. 이 경우에 매개변수의 갯수가 CPU 내의 총 레지스터 

       개수보다 많을 수 있다.

   -   매개변수가 레지스터로 직접 전달되나, 레지스터 크기보다 더 많은 매개변수가 존재하므로 좋지 않은 

        방법

​

#### 2) 블록 or 테이블을 통한 전송  

   -  매개변수를 메모리 내의 블록이나 테이블에 저장하고 해당 메모리의 주소가 레지스터에 전달된다.

​

#### 3) 스택을 통한 전송

   -  매개변수는 프로그램에 의해 스택(stack)으로 전달(push) 될 수도 있다. 

    -  매개변수는 프로그램에 의해 스택에 넣어지고, 운영체제에 의해 꺼내진다.


<br>

전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문에 2번 방법을 많이 사용한다.