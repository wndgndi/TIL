# 스케줄러란?

어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 모듈을 지칭한다. 스케줄러에 따라 프로세스 상태가 바뀌게 된다.
**즉, 한정적인 메모리를 프로세스가 효율적으로 사용 할 수있도록 작업을 할당시켜주는 역할을 한다.**

<br>

![schedular](https://blog.kakaocdn.net/dn/bvLzmH/btqQUZQfmrB/WpCsFyL0frr1S4cLZQK4d1/img.png)

<br>

---

## Scheduling Queue 3가지

-  **Job Queue** 
: 현재 시스템 내에 있는 모든 프로세스의 집합 (모든 프로세스들이 들어있다)
​

- **Ready Queue** 
: 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합 (ready 상태인 프로세스들이 들어있다)
​

- **Device Queue** 
: Device I/O 작업을 대기하고 있는 프로세스의 집합  
(I/O장치 사용을 대기하는 프로세스들이 들어있다)

​

각각의 Queue 에 프로세스들을 넣고 빼주는 스케줄러에도 크게 세 가지 종류(단기, 중기, 장기)가 존재한다.

<br>

---

### new : 프로세스 생성중
-  프로세스를 생성하고 있는 단계로 커널 공간에 PCB가 만들어진 상태

​

### ready : 프로세스가 CPU를 기다리는 상태

-  프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 모두 얻은 상태

-  아직 CPU를 받지는 않았지만 CPU를 할당 받으면 바로 실행 가능한 상태

-  ready상태를 가지는 여러개의 프로세스들이 존재할 수 있음

​

### running : 프로세스가 CPU를 할당받아 명령어를 수행 중인 상태

- 일반적으로 CPU가 하나이기 때문에, 여러 프로세스가 동시에 실행되도 실제로 실행중인 프로세스는 매 시점 하나 뿐임

​

### blocked : 프로세스가 CPU를 할당 받아도 당장 실행할 수 없는 상태

-  현재 프로세스가 I/O작업 등을 을 처리중 상태를 의미

​

### terminated : 프로세스의 실행 종료

-  프로세스의 실행이 완료되고 할당된 CPU를 반납, 커널공간내의 PCB는 남아 있음

​

### suspended : 프로세스의 중지 상태

- suspended 상태의 프로세스는 메모리를 강제로 뺏긴 상태로 특정한 이유로 프로세스의 수행이 정지된 상태로, 메모리에서 내려간 상태를 의미한다.

- 외부에서 다시 재개시키지 않는 이상 다시 활성화 될 수 없다. 중기 스케줄러에 의해 디스크로 스왑 아웃된 프로세스의 상태가 대표적인 suspended상태라 할 수 있음. suspended ready와 suspended  blocked가 있다.

<bre>

- blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state 로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.

​

1. suspended ready : ready 상태에 있던 프로세스가 디스크로 swap out

2. suspended blocked : block 상태에 있던 프로세스가 디스크로 swap out

<br>

---

## 스왑 아웃(Swap out)이란?

![swap out](https://blog.kakaocdn.net/dn/BxNuy/btqQIXGIxoW/52QHzy4hbF9gj62Bm5cgO0/img.png)

<br>

메모리에 많은 수의 프로세스가 올라와 프로세스당 할당된 메모리 양이 적어서 작업 수행에 문제가 생기고 이로 인해 디스크 I/O가 자주 발생하게 되는데 이는 시스템의 성능을 저하시킴.
→ 이를 해결하기 위해 메모리에 올라와 있는 프로세스 중 일부 프로세스의 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장하게 된다. 이와 같은 행위를 스왑 아웃(swap out)이라고 한다.

​

예를 들어 10개의 프로세스가 메모리에 올라와있는데 11번째 프로세스가 실행됨. 올릴 공간은 없고 올라와있는 어떤 프로세스는 계속 이벤트를 기다림. 메모리 낭비가 됨 
→ 그렇다면 기다리는 프로세스를 내리고 11번째 프로세스를 올리면 어떨까 내리는 행위가 바로 스왑 아웃이 됨.

<Br>

---

### ※ blocked ?

프로세스 A가 CPU를 할당받고(running상태) 명령어를 실행하다 I/O 작업을 해야 하는 경우, 디스크 I/O 작업은 CPU 처리 속도에 비해 오래 걸리는 작업이기 때문에 디스크 I/O 작업 동안은 CPU를 점유하고 있어도 다음 명령어를 수행하지 못하게 됨 -> CPU 낭비

때문에 디스크 I/O 작업을 하는 프로세스는 CPU를 반납하고 장치 큐에 가서 줄을 서게 된다(blocked 상태). 이후 디스크 컨트롤러에 의해 서비스를 받아 일을 수행하면(마그네틱 원판에서 원하는 데이터를 로컬 버퍼로 읽어오고 나면) 디스크 컨트롤러가 CPU에게 일을 끝났음을 알린다(인터럽트). 이후 프로세스 A는 장비 큐에서 빼내어 준비 큐로 넣어주고 프로세스 A가 한 일(로컬 버퍼에 저장)은 메모리에 올라가게 된다.


​

### ※ blocked와 suspended의 차이​

-  blocked : 잠시 중지되어있다(blocked) 끝나면 다시 ready상태로 돌아옴

- suspended : 잠시 중지되어 있다(suspendedn) 누군가가 재개시켜줘야 다시 ready상태로 돌아옴.

<Br>

---

## 장기 스케줄러(Long-term scheduler or job scheduler)

<br>


`작업 스케줄러`라고도 부르며 어떤 프로세스를 ready queue로 옮길지를 결정한다.

메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool 에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue 로 보낼지 결정하는 역할을 한다.
​
-  수 초, 분 단위로 비교적 가끔 호출되므로 속도가 느린 것이 허용됨

-  메모리와 디스크 사이의 스케줄링을 담당.

-  프로세스에 memory(및 각종 리소스)를 할당(admit)

-  degree of Multiprogramming 제어 메모리에 여러 프로그램이 올라가는 것) 몇 개의 프로그램이 올라갈 것인지를 제어

-  프로세스의 상태 : new -> ready (in memory)



*cf) 메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋지 않은 것이다. 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.*

​

**시분할 시스템(time sharing system)에서는 대부분 이 장기 스케줄러가 사용되지 않음**

→ 이유: 과거에는 적은 양의 메로리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 적어져 장기 스케줄러가 이를 조절하는 역할을 했지만 현대의 운영체제에서는 프로세스가  시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어주게 된다.

<br>

---

## 단기 스케줄러(Short-term scheduler or CPU scheduler)

​

-  CPU스케줄러라고도 하며 준비상태의 프로세스 중에서 어떤 것을 실행 상태로 바꿀지를 결정하는 스케줄러이다.

-  시분할 시스템에서는 타임 인터럽트로 인해 스케줄러가 호출된다.

-  CPU 와 메모리 사이의 스케줄링을 담당.

-  Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정.

-  프로세스에 스케줄링 알고리즘에 따라 CPU 를 할당(scheduler dispatch)​

-  프로세스의 상태 : ready -> running -> waiting -> ready

<Br>

---

## 중기 스케줄러(Medium-term scheduler or Swapper)

​
-  현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러.

-  여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)

-  프로세스에게서 memory 를 deallocate

-  degree of Multiprogramming 제어

-  프로세스의 상태 : ready -> suspended