# 프로세스 구조

프로그램의 실행 단위를 프로세스라고 한다.  프로세스는 '일반적'으로 아래와 같이 구성되어 있다.

<Br>

![process](https://images.velog.io/images/gndan4/post/a899c29d-ff14-4f34-9499-ad3a095ac8f3/image.png)

<br>

|text(CODE)|data|
|----------|----|
|컴파일된 소스 코드가 저장되는 영역(*기계어로 번역되어 적재되어 있다.*)|전역 변수/초기화된 데이터가 저장되는 영역|

<br>

|stack|heap|
|-----|----|
|임시 데이터(함수 호출, 로컬 변수 등)가 저장되는 영역|코드에서 동적으로 생성되는 데이터가 저장되는 영역  (*메모리 할당된 변수들을 관리한다.*)|

<br>

data는 정적 및 전역 변수가 적재되어 있다. DATA와 BSS로 나뉘는데, 각각 초기화된 것과 초기화되지 않은 것을 관리한다.


함수를 실행하게 되면 함수의 결과가 리턴될 주소가 스택에 저장되고, 함수의 지역 변수들이 차례로 스택에 쌓이게 된다.

함수가 다 실행되고 나면 스택에 있던 데이터들이 차례로 삭제되고, 스택에 저장되어 있던 리턴될 주소 또한 지워지면서 그 주소로 이동하게 된다.
이렇듯 스택을 이용하여 만든, 함수를 실행하기 위한 구조를 `스택 프레임`이라고 한다.​

프로세스에서 Text, DATA, BSS는 실행되자마자 고정된 메모리를 가진다. 
하지만 Stack은 위 → 아래,   Heap은 아래 → 위로 메모리 적재량이 유동적으로 바뀐다.
둘 다 Stack 자료구조 형식으로 LIFO이다.

<br>

---

## 프로세스와 컴퓨터 구조

​

-  PC(Program Counter)
: 코드를 한 줄 한 줄 가리키는 주소 레지스터. 
즉, 다음에 실행할 코드의 주소이다.
​

-  SP(Stack Pointer)
: 함수가 실행될 때 스택 프레임의 최상단 주소를 가리키는 레지스터.

​​
***EAX는 함수의 반환 값을 저장한다.***

<br>

---

## 함수 실행 예시 (컴퓨터 구조)
​
![func ex](https://images.velog.io/images/gndan4/post/474155a0-6d41-46a2-ac8e-161a95d92812/image.png)

<br>

코드 예시는 파이썬이며, 본래 파이썬은 인터프리터 언어이지만 예시에서는 컴파일러 언어로 가정하고 이해한다.

<br>

```
-  EAX 레지스터에는 리턴할 결과값이 담기게 된다.


-  함수가 호출되면 현재 스택 포인터의 최상단 값을 스택에도 저장하고 EBP 라는 레지스터에도 저장하게 된다. 
   EBP는 Stack의 최상단 주소를 담은 레지스터이다. 이는 함수를 타고 들어가다 문제가 발생했을 때 빠르게 추적하기 위해 존재한다.


-  함수를 리턴할 때 스택에 담겨있는 변수들을 차례로 삭제하고, 리턴 주소도 삭제하고, 함수를 실행할 때 스택에 저장된 EBP 레지스터의 값도
   삭제가 된다. 그리고 나서 PC가 리턴 주소를 가리키게 다음 코드가 실행된다.


-  이때, c에는 EAX 레지스터에 들어있던 값이 할당되고, DATA에 들어 있는 C의 값도 갱신된다.
```

<Br>
<br>

이처럼 프로세스 실행은 컴퓨터 구조와 많은 연관을 가지고 있다.

```
프로세스 내부 동작 예시


1. 컴파일 후 코드는 Text 영역에 들어간다.
(원래 Text는 위 그림과 달리 기존에 짠 코드와 반대 형식, 즉 Stack 형식으로 좌측에 있는 코드처럼 적재가 된다.)


2. 0000h : 함수 선언부라 아무일도 일어나지 않는다.
(PC=0000h, SP=1000h)


3. 0001h : 함수 구현부라 아무일도 일어나지 않는다.
(PC=0001h, SP=1000h)

​
4. 0002h : c = 0를 DATA 영역에 적재한다.
(PC=0002h, SP=1000h)


5. 0003h : c = func(1,2) 실행한다.
   두개로 나눈 이유는 기계어로 나누면 함수를 실행 → 결과 값을 c에 초기화하기 때문이다.

​
5-1. 1000h : 이 때 Stack과 EBP에 SP 값을 적재한다.
(push 1000h, EBP=1000h)
​

5-2. 0FFFh :그리고 Stack에 해당 함수가 끝났을 때 수행할 다음 주소를 적재한다.
(push 0004h (ret=0004h))
(PC=0003h, SP=0FFEh)

​
5. 0FFEh & 0FFDh : a=1 & b=2, 각 인자를 넣어준다.
(PC=0000h, SP=0FFCh)

​
6. return이 호출 되었다. return 값은 EAX라는 레지스터에 저장된다.
(PC=0001h, SP=00FCh)

​
7. 여태 Stack 적재된 func() 관련 메모리를 pop해준다. 그러면 ret=0004h를 통해 다음에 실행할 
코드 주소를 알고 다음을 실행한다.
(PC=0004h, SP=1000h)


8. 0004h : EAX에서 결과 값을 확인해서 c=func() 결과 값을 초기화한다.

​
9. 0005h : print(c)를 수행한다.

```

<br>

---

<Br>

## 프로세스 구조와 힙


프로세스 구조 중 힙(HEAP)은 컴파일 단에서 확인할 수 없는 동적인 요소를 생성할 수 있도록 지원하는 공간이다.

<br>

### [ 함수 실행 예시 (힙) ]

<Br>

![heap](https://images.velog.io/images/gndan4/post/0373c2a9-4fc3-4c5c-b249-768b1f278d35/image.png)

<Br>

-  C 언어를 예시로 하고 있다.

-  main() 또한 함수로 간주

-  컴퓨터 구조와 관련된 부분은 예시에서 생략

-  위 예시를 살펴보면 main() 함수 내부에서 malloc() 함수를 통해 동적으로 할당한 공간이 HEAP에 담겨있는 것을 볼 수 있다.

<Br>
<br>
<Br>

### [ BSS와 DATA 예시 ]

<Br>

![BSS, Data](https://images.velog.io/images/gndan4/post/c37f5825-40e2-408a-a22a-29204159e60f/image.png)

<Br>

-  C 언어 예시

-  main( ) 함수 밖의 전역 변수 중 초기화되지 않은 data1은 BSS에, 값이 1로 초기화된 data2는 DATA에 저장되어 있는 것을 확인할 수 있다.

-  main( ) 함수 내부에 있는 지역 변수 data는 STACK에 저장되어 있다.

<Br>

---

![process](https://velog.velcdn.com/images%2Fredgem92%2Fpost%2F3c075d25-cf54-4276-81ae-e2a402561e61%2Fimage.png)


위 그림은 5까지 수행한 시점이다. 그런데 만약에 func(a,b) 안에 다른 함수가 호출되면,

<br>  

![process2](https://velog.velcdn.com/images%2Fredgem92%2Fpost%2F9e67958c-88ac-4c0b-a761-3cb48b8de8d9%2Fimage.png)


0FFCh에 0FFCh가 적재되고 EBP 값도 0FFCh로 변경된다. 굳이 이렇게 복잡하게 가는 이유는 문제가 발생했을 때 추적Tracking 하기 위해서이다.

​<Br>

![Function](https://velog.velcdn.com/images%2Fredgem92%2Fpost%2F7510a83f-f3b6-4fa9-97c0-8543953a4ee3%2Fimage.png)

<br>

이 때 EBP는 함수2의 최상단 SP를 가지게 된다.

함수2에서 문제가 발생하게 되면 EBP를 통해 함수2에서 문제가 발생했는지, 어느 시점에서 문제가 발생했는지를 알 수 있다. 추가로 함수1이 수행된 시점까지도 알 수 있어 여러 로직으로 얽혀 있는 코드 이슈를 추적할 수 있게 되는 것이다.


